<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode929.独特的电子邮件地址</title>
      <link href="/lc/lc929/"/>
      <url>/lc/lc929/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode929-独特的电子邮件地址"><a href="#LeetCode929-独特的电子邮件地址" class="headerlink" title="LeetCode929.独特的电子邮件地址"></a>LeetCode929.独特的电子邮件地址</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>本题目来自LeetCode上的<a href="https://leetcode.cn/problems/unique-email-addresses/" target="_blank">『929.独特的电子邮件地址』 </a></p><p>每个 <strong>有效电子邮件地址</strong> 都由一个 <strong>本地名</strong> 和一个 <strong>域名</strong> 组成，以 <code>'@'</code> 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 <code>'.'</code> 或 <code>'+'</code> 。</p><p>例如，在 <code>alice@leetcode.com</code>中， <code>alice </code>是 本地名 ，而 <code>leetcode.com</code> 是 域名 。<br>如果在电子邮件地址的 <strong>本地名</strong> 部分中的某些字符之间添加句点（<code>'.'</code>），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 <strong>不适用于域名</strong> 。</p><p>例如，<code>"alice.z@leetcode.com” </code>和 <code>“alicez@leetcode.com”</code> 会转发到同一电子邮件地址。<br>如果在 <strong>本地名</strong> 中添加加号（<code>'+'</code>），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 <strong>不适用于域名</strong> 。</p><p>例如<code> m.y+name@email.com</code> 将转发到 <code>my@email.com</code>。<br>可以同时使用这两个规则。</p><p>给你一个字符串数组 <code>emails</code>，我们会向每个 <code>emails[i]</code> 发送一封电子邮件。返回实际收到邮件的不同地址数目。</p><h5 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h5><blockquote><p>输入：<code>emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]</code><br>输出：2<br>解释：实际收到邮件的是<code>"testemail@leetcode.com"</code> 和 <code>"testemail@lee.tcode.com"</code>。</p></blockquote><h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><ul><li><code>1 &lt;= emails.length &lt;= 100</code></li><li><code>1 &lt;= emails[i].length &lt;= 100</code></li><li><code>emails[i]</code> 由小写英文字母、<code>'+'</code>、<code>'.'</code> 和 <code>'@'</code> 组成</li><li>每个 <code>emails[i]</code> 都包含有且仅有一个 <code>'@'</code> 字符</li><li>所有本地名和域名都不为空</li><li>本地名不会以 <code>'+'</code> 字符作为开头</li></ul><h3 id="题解1-模拟"><a href="#题解1-模拟" class="headerlink" title="题解1 - 模拟"></a>题解1 - 模拟</h3><p>题目已经说明了每个字符串只有一个 <code>@</code>，将字符串按照 <code>@</code> 可以分成两部分，第一部分为本地名，我们需要删除所有 <code>.</code> 和第一个 <code>+</code> 及之后的内容；第二部分为域名，保持不变即可。</p><p><strong>注：</strong> 这里我直接套的字符串分割，但考虑到只有一个 <code>@</code>，所以并不需要这么麻烦。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> delimiters <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> ans<span class="token punctuation">;</span>        string<span class="token double-colon punctuation">::</span>size_type lastPos <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span>delimiters<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string<span class="token double-colon punctuation">::</span>size_type pos <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>delimiters<span class="token punctuation">,</span> lastPos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>string<span class="token double-colon punctuation">::</span>npos <span class="token operator">!=</span> pos <span class="token operator">||</span> string<span class="token double-colon punctuation">::</span>npos <span class="token operator">!=</span> lastPos<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>lastPos<span class="token punctuation">,</span> pos <span class="token operator">-</span> lastPos<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            lastPos <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span>delimiters<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>            pos <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>delimiters<span class="token punctuation">,</span> lastPos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numUniqueEmails</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> emails<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> email <span class="token operator">:</span> emails<span class="token punctuation">)</span> <span class="token punctuation">{</span>            vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> token <span class="token operator">=</span> <span class="token function">split</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span> <span class="token string">"@"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            string str<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> token<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'+'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token char">'.'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    str <span class="token operator">+=</span> c<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            st<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token char">'@'</span> <span class="token operator">+</span> token<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h3 id="题解2-正则表达式"><a href="#题解2-正则表达式" class="headerlink" title="题解2 - 正则表达式"></a>题解2 - 正则表达式</h3><p>将所有 <code>.</code> 和第一个 <code>+</code> 及之后的内容替换成空字符串。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numUniqueEmails</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> emails<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> st<span class="token punctuation">;</span>        regex <span class="token function">pattern</span><span class="token punctuation">(</span><span class="token string">"(\\.)(?=.*@)|(\\+.*)(?=@)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> email <span class="token operator">:</span> emails<span class="token punctuation">)</span> <span class="token punctuation">{</span>            st<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">regex_replace</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>略。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode478.在圆内随机生成点</title>
      <link href="/lc/lc478/"/>
      <url>/lc/lc478/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode478-在圆内随机生成点"><a href="#LeetCode478-在圆内随机生成点" class="headerlink" title="LeetCode478.在圆内随机生成点"></a>LeetCode478.在圆内随机生成点</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>本题目来自LeetCode上的<a href="https://leetcode.cn/problems/generate-random-point-in-a-circle/" target="_blank">『LeetCode478.在圆内随机生成点』 </a></p><p>给定圆的半径和圆心，实现一个函数，可以在圆中产生均匀随机点。</p><h5 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h5><blockquote><p><strong>输入</strong>:<br>[“Solution”,”randPoint”,”randPoint”,”randPoint”]<br>[[1.0, 0.0, 0.0], [], [], []]<br><strong>输出</strong>: [null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]<br><strong>解释</strong>:<br>Solution solution = new Solution(1.0, 0.0, 0.0);<br>solution.randPoint ();//返回[-0.02493，-0.38077]<br>solution.randPoint ();//返回[0.82314,0.38945]<br>solution.randPoint ();//返回[0.36572,0.17248]</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果不考虑等概率，直接返回圆心就行（笑</p><p>考虑等概率的话，就需要一番分析啦，本文从两个角度进行讲解。</p><h5 id="角度1-几何概型角度"><a href="#角度1-几何概型角度" class="headerlink" title="角度1 - 几何概型角度"></a>角度1 - 几何概型角度</h5><p>首先考虑一个朴素的几何概型想法：</p><p>在 $[0,r]$ 的线段上随机取值，取到 $[0,\frac{r}{2}]$ 的概率为 $\frac{1}{2}$，现在将这个线段的一端固定，另一端旋转一周，线段扫过的图形为一个以 $r$ 为半径的圆，此时线段 $[0,\frac{r}{2}]$ 扫过的圆面积为整个圆面积的 $\frac{1}{4}$，圆内随机取一个点，这个点落在小圆的概率为 $\frac{1}{4}$。因此，在一维中等概率取一点，旋转成圆之后就不是等概率了。</p><h5 id="角度2-概率论角度"><a href="#角度2-概率论角度" class="headerlink" title="角度2 - 概率论角度"></a>角度2 - 概率论角度</h5><p>下面从概率论角度分析。</p><p>不失一般性，我们以单位圆为例，在单位圆上任取一点，这个点落到某一圆周上的长度与该圆周的周长成正比，从而也就与该圆周的半径成正比，设单位圆的概率密度函数 $f(r)=kr$，因此：</p><p>$$1=P(0\leq r\leq 1)=\int_0^1kr\ dr=\frac{1}{2}k$$</p><p>得 $k=2$，PDF：$f(r)=2r$</p><p>得到PDF后，就可以算出分布函数CDF：</p><p>$$F(r)=\int_0^rf(t)\ dt=r^2$$</p><p>通过上面的分析，想要得到等概率，需要在 $[0,1]$ 内等概率取 $F(r)$ 的值，$r=\sqrt{F(r)}$，然后再对单位圆进行放缩。</p><h5 id="坐标生成"><a href="#坐标生成" class="headerlink" title="坐标生成"></a>坐标生成</h5><p>根据极坐标生成圆心的坐标：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd><msup><mi>ρ</mi><mn>2</mn></msup></mtd><mtd><mi></mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mtd></mtr><mtr><mtd><mi>x</mi></mtd><mtd><mi></mi><mo>=</mo><mi>ρ</mi><mi>cos</mi><mo data-mjx-texclass="NONE">⁡</mo><mrow><mi>θ</mi></mrow></mtd></mtr><mtr><mtd><mi>y</mi></mtd><mtd><mi></mi><mo>=</mo><mi>ρ</mi><mi>sin</mi><mo data-mjx-texclass="NONE">⁡</mo><mrow><mi>θ</mi></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></math></p><p>其中，$\theta$ 可在 $[0, 2\pi]$ 中等概率生成。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">double</span> PI <span class="token operator">=</span> <span class="token function">acos</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> r<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>    mt19937 gen<span class="token punctuation">{</span> random_device<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    uniform_real_distribution<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> dis<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token keyword">double</span> radius<span class="token punctuation">,</span> <span class="token keyword">double</span> x_center<span class="token punctuation">,</span> <span class="token keyword">double</span> y_center<span class="token punctuation">)</span> <span class="token operator">:</span>    <span class="token function">r</span><span class="token punctuation">(</span>radius<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">x</span><span class="token punctuation">(</span>x_center<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y_center<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">dis</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token function">randPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> theta <span class="token operator">=</span> <span class="token function">dis</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> PI<span class="token punctuation">;</span>        <span class="token keyword">double</span> rho <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">dis</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> r<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>x <span class="token operator">+</span> rho <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token punctuation">,</span> y <span class="token operator">+</span> rho <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>不考虑生成随机数的复杂度</p><ul><li><p>时间复杂度：$O(1)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode829.连续整数求和</title>
      <link href="/lc/lc829/"/>
      <url>/lc/lc829/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode829-连续整数求和"><a href="#LeetCode829-连续整数求和" class="headerlink" title="LeetCode829.连续整数求和"></a>LeetCode829.连续整数求和</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>本题目来自LeetCode上的<a href="https://leetcode.cn/problems/consecutive-numbers-sum/" target="_blank">『829.连续整数求和』 </a></p><p>给定一个正整数 <code>n</code>，返回连续正整数满足所有数字之和为 <code>n</code> 的组数 。</p><h5 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h5><blockquote><p><strong>输入</strong>: n = 5<br><strong>输出</strong>: 2<br><strong>解释</strong>: 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设这组连续的数字的首个数字为 $a$，长度为 $k$，则由等差数列和可知</p><p>$$\frac{(a+a+k-1)k}{2}=n$$</p><p>得 $(2a+k-1)k=2n$，推出 $k\mid 2n$</p><p>再变形可得 $2a=\frac{2n}{k}-k+1$，由 $a\in {x|x\ge 1\wedge x\in N}$ 推出 $2\mid (\frac{2n}{k}-k+1)$</p><p>还能推出 $\frac{2n}{k}-k+1\ge2$，进而得到 $\frac{2n}{k}\ge k+1&gt;k$，即 $k&lt;\sqrt{2n}$</p><p>综上，我们枚举 $k$，检查是否符合上述两个整除关系即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">consecutiveNumbersSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> limit <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> limit<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">%</span> i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">/</span> i <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>ans<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：$O(\sqrt{2n})$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode450.删除二叉搜索树中的节点</title>
      <link href="/lc/lc450/"/>
      <url>/lc/lc450/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode450-删除二叉搜索树中的节点"><a href="#LeetCode450-删除二叉搜索树中的节点" class="headerlink" title="LeetCode450.删除二叉搜索树中的节点"></a>LeetCode450.删除二叉搜索树中的节点</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>本题目来自 LeetCode 上的<a href="https://leetcode.cn/problems/delete-node-in-a-bst/" target="_blank">『450.删除二叉搜索树中的节点』</a></p><p>给定一个二叉搜索树，要求删除指定值对应的结点。</p><h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5><blockquote><p><strong>输入</strong>：root = [5,3,6,2,4,null,7], key = 3<br><strong>输出</strong>：[5,4,6,2,null,null,7]<br><strong>解释</strong>：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>经典的二叉搜索树删除节点问题。</p><p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/LeetCode/LC450.png" alt="LC450.png"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            root<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            root<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> root<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> root<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            TreeNode<span class="token operator">*</span> curr <span class="token operator">=</span> root<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>                curr <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            curr<span class="token operator">-&gt;</span>left <span class="token operator">=</span> root<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：$O(n)$</p></li><li><p>空间复杂度：$O(1)$</p></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode433.最小基因变化</title>
      <link href="/lc/lc433/"/>
      <url>/lc/lc433/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode433-最小基因变化"><a href="#LeetCode433-最小基因变化" class="headerlink" title="LeetCode433.最小基因变化"></a>LeetCode433.最小基因变化</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>本题目来自 LeetCode 上的<a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank">『433. 最小基因变化』</a></p><p>一组基因序列由8个字符组成。一次基因变化定义为 <strong>基因序列中的一个字符</strong> 发生变化。<br>设 <code>bank</code> 中为所有合法的基因变化，求基因 <code>start</code> 到 <code>end</code> 需要经历几次基因变化。</p><h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5><blockquote><p>输入：start = “AACCGGTT”, end = “AACCGGTA”, bank = [“AACCGGTA”]</p><p>输出：1</p></blockquote><h5 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h5><blockquote><p>输入：start = “AAAAACCC”, end = “AACCCCCC”, bank = [“AAAACCCC”,”AAACCCCC”,”AACCCCCC”]</p><p>输出：3</p></blockquote><h5 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h5><ul><li><code>start.length == 8</code></li><li><code>end.length == 8</code></li><li><code>0 &lt;= bank.length &lt;= 10</code></li><li><code>bank[i].length == 8</code></li><li><code>start</code>、<code>end</code> 和 <code>bank[i]</code> 仅由字符 <code>['A', 'C', 'G', 'T']</code> 组成</li></ul><h3 id="题解—预处理-BFS"><a href="#题解—预处理-BFS" class="headerlink" title="题解—预处理+BFS"></a>题解—预处理+BFS</h3><p>我们用 $0,1,2,…$ 为<code>bank</code> 中的基因编号，以这些编号为顶点建无向图，建图规则如下：</p><ul><li>如果两个基因序列的 <strong>距离</strong> 为1，即两个基因序列只有一个字符不同，那么就在这两个顶点之间加上一条边。</li><li>为了方便搜索，我们将基因序列 <code>start</code> 也加入到 <code>bank</code> 的末尾。</li></ul><p>建图完毕后，问题就转化成求 <code>start</code> 所在点 <code>x</code> 到 <code>end</code> 所在点 <code>y</code> 之间的最小距离，如果两点不连通就返回 <code>-1</code>。<br>无权值图的单源最短路径可以使用 BFS。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> graph<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> dist <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>dist<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dist<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> bank<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">distance</span><span class="token punctuation">(</span>bank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> bank<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    graph<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">visited</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> poll <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>poll <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> v <span class="token operator">:</span> graph<span class="token punctuation">[</span>poll<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token operator">++</span>ans<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minMutation</span><span class="token punctuation">(</span>string start<span class="token punctuation">,</span> string end<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{</span>        bank<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> bank<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        graph<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">build</span><span class="token punctuation">(</span>bank<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                idx <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">bfs</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> idx<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：设 <code>bank</code> 长度为 $n$，基因序列长度为 $m$，则建图的复杂度为 $O(m\times n^2)$，搜索时，最多搜索 $n$ 个顶点，因此搜索的复杂度为 $n$，综合复杂度为 $O(m\times n^2)$</li><li>空间复杂度 $O(n^2)$</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论1-1.图的介绍</title>
      <link href="/graph/introduction-to-graph/"/>
      <url>/graph/introduction-to-graph/</url>
      
        <content type="html"><![CDATA[<h1 id="图论1-1-图的介绍"><a href="#图论1-1-图的介绍" class="headerlink" title="图论1-1.图的介绍"></a>图论1-1.图的介绍</h1><p>图可以表示生活中的许多东西，它是由一个点集以及点集中一些点对的连线构成。如一个人就可以表示成一个点，两个点之间的连线表示朋友关系等。</p><h2 id="1-1-图的表示"><a href="#1-1-图的表示" class="headerlink" title="1.1 图的表示"></a>1.1 图的表示</h2><p>图（Graph）是由一个点集（vertices, <strong>V</strong>）和一个边集（edges, <strong>E</strong>）构成，表示为 <strong><em>G(V, E)。</em></strong><br>有时候，图也被定义为一个有序三元组  $(V(G),E(G),\phi_G)$，其中 $\phi_G$被称为关联函数，$\phi(e)=uv$表示边$e$连接$uv$两个顶点。</p><ol><li><strong>顶点</strong>：是图的基本要素，也叫做节点（node）。顶点可以带有标记也可以不带。</li><li><strong>边</strong>：用于连接任意两个顶点（也可以自己连自己）， 有时候边也叫做弧（arc）。</li><li><strong>顶点数</strong>：$\upsilon$；<strong>边数：</strong>$\varepsilon$</li><li>如果两个图 G 和 H，有$V(G)=V(H),E(G)=E(H),\phi(G)=\phi(H)$，则这两个图** 恒等**$G=H$。</li><li>如果两个图 **只有 **边和顶点的标号不同，则这两个图 <strong>同构</strong>$G\cong H$</li></ol><p>例：</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/1.jpeg" style="zoom:50%;"><ol><li>一条边的顶点与这条边称为<strong>关联</strong>，反之亦然。</li><li>与同一条边关联的叫做相邻，反之亦然。</li><li>端点重合为一个点的边称为环，上图顶点6就存在一个环。</li></ol><h2 id="1-2-图的种类"><a href="#1-2-图的种类" class="headerlink" title="1.2 图的种类"></a>1.2 图的种类</h2><h4 id="1-空图（Null-graph）"><a href="#1-空图（Null-graph）" class="headerlink" title="1. 空图（Null graph）"></a>1. 空图（Null graph）</h4><p>没有边的图叫做空图。</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/2.jpeg" style="zoom:50%;"><h4 id="2-平凡图（Trivial-Graph）"><a href="#2-平凡图（Trivial-Graph）" class="headerlink" title="2. 平凡图（Trivial Graph）"></a>2. 平凡图（Trivial Graph）</h4><p>只有一个顶点的图叫做平凡图，它是最小的图。其他的所有图都叫做非平凡图（Nontrivial graph）。</p><h4 id="3-无向图（Undirected-Graph）"><a href="#3-无向图（Undirected-Graph）" class="headerlink" title="3. 无向图（Undirected Graph）"></a>3. 无向图（Undirected Graph）</h4><p>边没有方向的图叫做无向图。</p><h4 id="4-有向图（Directed-Graph）"><a href="#4-有向图（Directed-Graph）" class="headerlink" title="4. 有向图（Directed Graph）"></a>4. 有向图（Directed Graph）</h4><p>边有方向的图叫做有向图。</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/3.jpeg" style="zoom:50%;"><h4 id="5-连通图（Connected-Graph）"><a href="#5-连通图（Connected-Graph）" class="headerlink" title="5. 连通图（Connected Graph）"></a>5. 连通图（Connected Graph）</h4><p>从一个点开始，可以访问到其他任意点的图叫做连通图。</p><h4 id="6-非连通图（Disconnected-Graph）"><a href="#6-非连通图（Disconnected-Graph）" class="headerlink" title="6. 非连通图（Disconnected Graph）"></a>6. 非连通图（Disconnected Graph）</h4><p>从一个点开始，不能访问到其他任意点的图叫做连通图。</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/4.jpeg" style="zoom:50%;"><h4 id="7-正则图（Regular-Graph）"><a href="#7-正则图（Regular-Graph）" class="headerlink" title="7. 正则图（Regular Graph）"></a>7. 正则图（Regular Graph）</h4><p>每个顶点度都相同的图叫做正则图。每个顶点度为 K 的图叫做 <strong>K-正则图（K-Regular）</strong></p><h4 id="8-完全图（Complete-Graph）"><a href="#8-完全图（Complete-Graph）" class="headerlink" title="8. 完全图（Complete Graph）"></a>8. 完全图（Complete Graph）</h4><p>每个顶点都与其他顶点相邻的图叫做完全图，完全图是一个$\upsilon-1$正则图。</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/5.jpeg" style="zoom:50%;"><h4 id="9-圈图（Cycle-Graph）"><a href="#9-圈图（Cycle-Graph）" class="headerlink" title="9. 圈图（Cycle Graph）"></a>9. 圈图（Cycle Graph）</h4><p>如果一个图自身就是一个环，就叫做圈图，也称为<strong>自环</strong>。</p><h4 id="10-有环图（Cyclic-Graph）"><a href="#10-有环图（Cyclic-Graph）" class="headerlink" title="10. 有环图（Cyclic Graph）"></a>10. 有环图（Cyclic Graph）</h4><p>一个图至少含有一个环，称为有环图。</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/6.jpeg" style="zoom:50%;"><h4 id="11-无环图（acyclic-graph）、"><a href="#11-无环图（acyclic-graph）、" class="headerlink" title="11. 无环图（acyclic graph）、"></a>11. 无环图（<strong>acyclic graph</strong>）、</h4><p>一个图不包含环，称为无环图。</p><h4 id="12-有向无环图（Directed-Acyclic-Graph）"><a href="#12-有向无环图（Directed-Acyclic-Graph）" class="headerlink" title="12. 有向无环图（Directed Acyclic Graph）"></a>12. 有向无环图（Directed Acyclic Graph）</h4><p>一个有向图不包含环，称为有向无环图。</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/7.jpeg" style="zoom:50%;"><h4 id="13-二分图（Bipartite-Graph）"><a href="#13-二分图（Bipartite-Graph）" class="headerlink" title="13. 二分图（Bipartite Graph）"></a>13. 二分图（Bipartite Graph）</h4><p>如果一个图的顶点可以分成两个集合，且每个集合内部的顶点之间不存在边，这样的图叫做二分图，也叫做二部图。</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/8.jpeg" style="zoom:50%;"><h4 id="14-简单图（Simple-graph）"><a href="#14-简单图（Simple-graph）" class="headerlink" title="14. 简单图（Simple graph）"></a>14. 简单图（Simple graph）</h4><p>如果一个图既没有环也没有重边，叫做简单图。</p><h2 id="1-3-一个结论"><a href="#1-3-一个结论" class="headerlink" title="1.3 一个结论"></a>1.3 一个结论</h2><p>如果 G 是简单图，则$\varepsilon\leq C_\upsilon^2$</p><h2 id="1-4-图的表示"><a href="#1-4-图的表示" class="headerlink" title="1.4 图的表示"></a>1.4 图的表示</h2><p>在数据结构中，图有两种表示方法。</p><h4 id="1-邻接矩阵（Adjacency-Matrix）"><a href="#1-邻接矩阵（Adjacency-Matrix）" class="headerlink" title="1. 邻接矩阵（Adjacency Matrix）"></a>1. 邻接矩阵（Adjacency Matrix）</h4><p>使用一个二维的矩阵表示图，矩阵的行和列都为顶点编号，若顶点$1,2$直接有一条边，则矩阵的位置$(1,2)$置一。</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/9.jpeg" style="zoom:50%;"><h4 id="2-邻接表（Adjacency-List）"><a href="#2-邻接表（Adjacency-List）" class="headerlink" title="2. 邻接表（Adjacency List）"></a>2. 邻接表（Adjacency List）</h4><p>每一个顶点对应一个链表，链表的头节点为顶点编号，后面的节点为相邻的顶点。</p><img src="https://shuocloud-db.oss-cn-hangzhou.aliyuncs.com/graph_theory/1-1/10.jpeg" style="zoom:50%;"><h4 id="3-两种数据结构对比"><a href="#3-两种数据结构对比" class="headerlink" title="3. 两种数据结构对比"></a>3. 两种数据结构对比</h4><p>当图含有较多边的时候，建议使用邻接矩阵。</p><table><thead><tr><th></th><th>邻接矩阵</th><th>邻接表</th></tr></thead><tbody><tr><td>添加一条边</td><td>$O(1)$</td><td>$O(1)$</td></tr><tr><td>删除一条边</td><td>$O(1)$</td><td>$O(n)$</td></tr><tr><td>初始化</td><td>$O(n*n)$</td><td>$O(n)$</td></tr></tbody></table><hr><p>参考资料：<a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环问题</title>
      <link href="/classic-problems/josephus/"/>
      <url>/classic-problems/josephus/</url>
      
        <content type="html"><![CDATA[<h3 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h3><p>$n$ 个人围成一圈，从第一个开始报数，数到第 $m$ 个的人会被杀掉，直到剩下一个人，求解最后存活的是哪一个人。</p><h3 id="抽象描述"><a href="#抽象描述" class="headerlink" title="抽象描述"></a>抽象描述</h3><p>$0,1,2,…,n-1$ 这些数字围成一圈，从第 $0$ 个数字开始，每次删除第 $m$ 个数字，求最后剩下的那个数字。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote><p><strong>Definition 1: $f(n,m)$</strong></p><p>$f(n,m)$：表示 $n$ 个数字围成一圈，从第 $0$ 个数字开始，每次删除第 $m$ 个数字，最后剩下的那个数字。</p></blockquote><p>$0,1,2,…,n-1$ 这 $n$ 个数字中，被删除的是数字 $(m-1)%n$，令 $k=(m-1)%n$，则第一次删除后剩下的数字为 $0,1,2,…,k-1,k+1,…,n-1$，下一次删除是从 $k+1$ 开始数，于是我们可以把该序列改写为 $k+1,…,n-1,0,1,…,k-1$。</p><blockquote><p><strong>Definition 2: $g(n-1,m)$</strong></p><p>$g(n-1,m)$：表示从 $k+1,…,n-1,0,1,…,k-1$ 这 $n-1$ 个数字中，从 $k+1$ 开始，每次删除第 $m$ 个数字，最后剩下的那个数字。</p></blockquote><p>显然，$f(n,m)=g(n-1,m)$。（因为最后剩下的数字是同一个）</p><blockquote><p><strong>Definition 3: $h(x)$</strong></p><p>$h(x)$：一个从 $f(n-1,m)$ 到 $g(n-1,m)$ 的映射。</p></blockquote><p>下面求解这个 $h(x)$，观察如下映射规则：<br>$0\rightarrow k+1$</p><p>$1\rightarrow k+2$<br>$…$<br>$n-3\rightarrow k-2$<br>$n-2\rightarrow k-1$<br>可得：$h(x)=(x+k+1)%n$，因此有:</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt"><mtr><mtd><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo></mtd><mtd><mi></mi><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd></mtd><mtd><mi></mi><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd></mtd><mtd><mi></mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi></mtd></mtr><mtr><mtd></mtd><mtd><mi></mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi></mtd></mtr><mtr><mtd></mtd><mtd><mi></mi><mover><mo>=</mo><mrow><mo>①</mo></mrow></mover><mrow></mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi></mtd></mtr><mtr><mtd></mtd><mtd><mi></mi><mover><mo>=</mo><mrow><mo>②</mo></mrow></mover><mrow></mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi></mtd></mtr><mtr><mtd></mtd><mtd><mi></mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi></mtd></mtr></mtable></math></p><p>其中$①：0\leq f(n-1,m)\leq n-2$，$1\leq f(n-1,m)+1\leq n-1$，因此 $(f(n-1,m)+1)%n= f(n-1,m)+1$</p><p>$②:distributive\ law:(a+b)%p=(a%p+b%p)%p$</p><p>最终我们有递推公式：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">{</mo><mtable columnalign="center left" columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>0</mn></mtd><mtd><mi>n</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi></mtd><mtd><mi>n</mi><mo>&gt;</mo><mn>1</mn></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE" fence="true" stretchy="true" symmetric="true"></mo></mrow></math></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">josephus</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">josephus</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">josephus</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> dp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dp <span class="token operator">=</span> <span class="token punctuation">(</span>dp <span class="token operator">+</span> m<span class="token punctuation">)</span> <span class="token operator">%</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 经典算法问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典问题 </tag>
            
            <tag> 约瑟夫环 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
